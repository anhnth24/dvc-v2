# Database Partitioning Strategy - High Volume Tables

## OVERVIEW

This document outlines the partitioning strategy for high-volume tables in the DVC v2 system to improve performance, manageability, and maintenance. The primary focus is on `HOSO` (case management) and `AUDIT_LOG` tables, which handle 800,000 documents/month and extensive audit tracking.

## PARTITIONING PRINCIPLES

### Performance Goals
- **Query Performance**: <20ms for typical case lookups
- **Maintenance**: Minimal impact on operations during maintenance
- **Storage**: Efficient storage allocation and archiving
- **Scalability**: Handle 1M+ cases per year growth

### Partitioning Strategy
- **Range Partitioning**: By date for time-series data
- **Hash Partitioning**: For even distribution when date isn't suitable
- **Composite Partitioning**: Combination of range and hash for complex scenarios

## HOSO TABLE PARTITIONING

### Current Volume Analysis
- **Current**: ~800,000 cases/month
- **Projected**: 1.2M cases/month by 2025
- **Growth**: 50% year-over-year
- **Retention**: 10 years legal requirement

### Partitioning Strategy for HOSO

```sql
-- 1. Create partition function for HOSO table (monthly partitioning)
CREATE PARTITION FUNCTION pf_HOSO_Monthly (DATETIME2)
AS RANGE RIGHT FOR VALUES (
    '2024-01-01', '2024-02-01', '2024-03-01', '2024-04-01',
    '2024-05-01', '2024-06-01', '2024-07-01', '2024-08-01',
    '2024-09-01', '2024-10-01', '2024-11-01', '2024-12-01',
    '2025-01-01', '2025-02-01', '2025-03-01', '2025-04-01',
    '2025-05-01', '2025-06-01', '2025-07-01', '2025-08-01',
    '2025-09-01', '2025-10-01', '2025-11-01', '2025-12-01',
    '2026-01-01', '2026-02-01', '2026-03-01', '2026-04-01',
    '2026-05-01', '2026-06-01', '2026-07-01', '2026-08-01',
    '2026-09-01', '2026-10-01', '2026-11-01', '2026-12-01'
);
GO

-- 2. Create partition scheme for HOSO
CREATE PARTITION SCHEME ps_HOSO_Monthly
AS PARTITION pf_HOSO_Monthly
TO (
    [HOSO_2024_01], [HOSO_2024_02], [HOSO_2024_03], [HOSO_2024_04],
    [HOSO_2024_05], [HOSO_2024_06], [HOSO_2024_07], [HOSO_2024_08],
    [HOSO_2024_09], [HOSO_2024_10], [HOSO_2024_11], [HOSO_2024_12],
    [HOSO_2025_01], [HOSO_2025_02], [HOSO_2025_03], [HOSO_2025_04],
    [HOSO_2025_05], [HOSO_2025_06], [HOSO_2025_07], [HOSO_2025_08],
    [HOSO_2025_09], [HOSO_2025_10], [HOSO_2025_11], [HOSO_2025_12],
    [HOSO_2026_01], [HOSO_2026_02], [HOSO_2026_03], [HOSO_2026_04],
    [HOSO_2026_05], [HOSO_2026_06], [HOSO_2026_07], [HOSO_2026_08],
    [HOSO_2026_09], [HOSO_2026_10], [HOSO_2026_11], [HOSO_2026_12],
    [PRIMARY]
);
GO

-- 3. Create filegroups for HOSO partitions
ALTER DATABASE [DVC_v2] ADD FILEGROUP [HOSO_2024_01];
ALTER DATABASE [DVC_v2] ADD FILEGROUP [HOSO_2024_02];
ALTER DATABASE [DVC_v2] ADD FILEGROUP [HOSO_2024_03];
ALTER DATABASE [DVC_v2] ADD FILEGROUP [HOSO_2024_04];
ALTER DATABASE [DVC_v2] ADD FILEGROUP [HOSO_2024_05];
ALTER DATABASE [DVC_v2] ADD FILEGROUP [HOSO_2024_06];
ALTER DATABASE [DVC_v2] ADD FILEGROUP [HOSO_2024_07];
ALTER DATABASE [DVC_v2] ADD FILEGROUP [HOSO_2024_08];
ALTER DATABASE [DVC_v2] ADD FILEGROUP [HOSO_2024_09];
ALTER DATABASE [DVC_v2] ADD FILEGROUP [HOSO_2024_10];
ALTER DATABASE [DVC_v2] ADD FILEGROUP [HOSO_2024_11];
ALTER DATABASE [DVC_v2] ADD FILEGROUP [HOSO_2024_12];
-- Continue for 2025, 2026...
GO

-- 4. Add files to filegroups (example for January 2024)
ALTER DATABASE [DVC_v2]
ADD FILE (
    NAME = 'HOSO_2024_01_Data',
    FILENAME = 'D:\Database\DVC_v2\Data\HOSO_2024_01.ndf',
    SIZE = 1GB,
    MAXSIZE = 50GB,
    FILEGROWTH = 256MB
) TO FILEGROUP [HOSO_2024_01];
GO

-- 5. Modify HOSO table to use partitioning (requires table rebuild)
-- This would be done during migration - shown conceptually
/*
CREATE TABLE [case].HOSO_Partitioned (
    -- All existing columns from HOSO table
    HoSoID BIGINT IDENTITY(1,1),
    -- ... other columns ...
    NgayNop DATETIME2 DEFAULT GETDATE(), -- Partition key
    -- ... remaining columns ...

    CONSTRAINT PK_HOSO_Partitioned PRIMARY KEY (HoSoID, NgayNop)
) ON ps_HOSO_Monthly(NgayNop);
*/
```

### HOSO Partition Maintenance

```sql
-- Automated partition maintenance stored procedure
CREATE PROCEDURE [case].sp_MaintainHOSOPartitions
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @NextMonth DATE = DATEADD(MONTH, 1, EOMONTH(GETDATE()));
    DECLARE @FileGroupName NVARCHAR(100) = 'HOSO_' + FORMAT(@NextMonth, 'yyyy_MM');
    DECLARE @FileName NVARCHAR(100) = @FileGroupName + '_Data';
    DECLARE @FilePath NVARCHAR(500) = 'D:\Database\DVC_v2\Data\' + @FileGroupName + '.ndf';

    -- Check if next month's partition exists
    IF NOT EXISTS (
        SELECT 1 FROM sys.filegroups
        WHERE name = @FileGroupName
    )
    BEGIN
        -- Add filegroup
        EXEC('ALTER DATABASE [DVC_v2] ADD FILEGROUP [' + @FileGroupName + ']');

        -- Add file to filegroup
        EXEC('ALTER DATABASE [DVC_v2]
              ADD FILE (
                  NAME = ''' + @FileName + ''',
                  FILENAME = ''' + @FilePath + ''',
                  SIZE = 1GB,
                  MAXSIZE = 50GB,
                  FILEGROWTH = 256MB
              ) TO FILEGROUP [' + @FileGroupName + ']');

        -- Split partition
        EXEC('ALTER PARTITION SCHEME ps_HOSO_Monthly NEXT USED [' + @FileGroupName + ']');
        EXEC('ALTER PARTITION FUNCTION pf_HOSO_Monthly() SPLIT RANGE (''' + CAST(@NextMonth AS VARCHAR(10)) + ''')');

        PRINT 'Created partition for ' + @FileGroupName;
    END

    -- Archive old partitions (older than 3 years)
    DECLARE @ArchiveDate DATE = DATEADD(YEAR, -3, GETDATE());
    -- Implementation for archiving old partitions
    -- (Move to archive database and remove from active partition scheme)
END
GO

-- Schedule the partition maintenance job
EXEC msdb.dbo.sp_add_job
    @job_name = N'HOSO Partition Maintenance',
    @enabled = 1,
    @description = N'Monthly HOSO table partition maintenance';

EXEC msdb.dbo.sp_add_jobstep
    @job_name = N'HOSO Partition Maintenance',
    @step_name = N'Maintain Partitions',
    @command = N'EXEC [case].sp_MaintainHOSOPartitions',
    @database_name = N'DVC_v2';

EXEC msdb.dbo.sp_add_schedule
    @schedule_name = N'Monthly Partition Maintenance',
    @freq_type = 4, -- Daily
    @freq_interval = 1,
    @freq_subday_type = 1, -- Once
    @active_start_date = 20240101,
    @active_start_time = 20000; -- 2:00 AM

EXEC msdb.dbo.sp_attach_schedule
    @job_name = N'HOSO Partition Maintenance',
    @schedule_name = N'Monthly Partition Maintenance';
GO
```

## AUDIT_LOG TABLE PARTITIONING

### Current Volume Analysis
- **Current**: ~10M audit records/month
- **Projected**: 15M records/month by 2025
- **Growth**: User activity increase + system monitoring
- **Retention**: 7 years compliance requirement

### Partitioning Strategy for AUDIT_LOG

```sql
-- 1. Create partition function for AUDIT_LOG (weekly partitioning due to high volume)
CREATE PARTITION FUNCTION pf_AUDIT_LOG_Weekly (DATETIME2)
AS RANGE RIGHT FOR VALUES (
    -- 2024 weeks (52 weeks)
    '2024-01-01', '2024-01-08', '2024-01-15', '2024-01-22', '2024-01-29',
    '2024-02-05', '2024-02-12', '2024-02-19', '2024-02-26',
    '2024-03-04', '2024-03-11', '2024-03-18', '2024-03-25',
    '2024-04-01', '2024-04-08', '2024-04-15', '2024-04-22', '2024-04-29',
    '2024-05-06', '2024-05-13', '2024-05-20', '2024-05-27',
    '2024-06-03', '2024-06-10', '2024-06-17', '2024-06-24',
    '2024-07-01', '2024-07-08', '2024-07-15', '2024-07-22', '2024-07-29',
    '2024-08-05', '2024-08-12', '2024-08-19', '2024-08-26',
    '2024-09-02', '2024-09-09', '2024-09-16', '2024-09-23', '2024-09-30',
    '2024-10-07', '2024-10-14', '2024-10-21', '2024-10-28',
    '2024-11-04', '2024-11-11', '2024-11-18', '2024-11-25',
    '2024-12-02', '2024-12-09', '2024-12-16', '2024-12-23', '2024-12-30',
    -- Continue pattern for 2025, 2026...
    '2025-01-06', '2025-01-13', '2025-01-20', '2025-01-27'
    -- ... additional weeks as needed
);
GO

-- 2. Create partition scheme for AUDIT_LOG
CREATE PARTITION SCHEME ps_AUDIT_LOG_Weekly
AS PARTITION pf_AUDIT_LOG_Weekly
TO (
    [AUDIT_2024_W01], [AUDIT_2024_W02], [AUDIT_2024_W03], [AUDIT_2024_W04],
    [AUDIT_2024_W05], [AUDIT_2024_W06], [AUDIT_2024_W07], [AUDIT_2024_W08],
    -- Continue for all weeks...
    [PRIMARY]
);
GO

-- 3. Composite partitioning for AUDIT_LOG by date and action type
CREATE PARTITION FUNCTION pf_AUDIT_LOG_ActionType (NVARCHAR(100))
AS RANGE LEFT FOR VALUES (
    'AUTHENTICATION', 'AUTHORIZATION', 'DOCUMENT', 'PAYMENT', 'SYSTEM', 'WORKFLOW'
);
GO

CREATE PARTITION SCHEME ps_AUDIT_LOG_ActionType
AS PARTITION pf_AUDIT_LOG_ActionType
TO (
    [AUDIT_AUTH], [AUDIT_AUTHZ], [AUDIT_DOC], [AUDIT_PAY], [AUDIT_SYS], [AUDIT_WF], [PRIMARY]
);
GO
```

### AUDIT_LOG Partition Maintenance

```sql
-- Automated audit log partition maintenance
CREATE PROCEDURE [audit].sp_MaintainAuditLogPartitions
AS
BEGIN
    SET NOCOUNT ON;

    -- Add next week's partition
    DECLARE @NextWeek DATE = DATEADD(WEEK, 1, DATEADD(WEEK, DATEDIFF(WEEK, 0, GETDATE()), 0));
    DECLARE @WeekNumber INT = DATEPART(WEEK, @NextWeek);
    DECLARE @Year INT = YEAR(@NextWeek);
    DECLARE @FileGroupName NVARCHAR(100) = 'AUDIT_' + CAST(@Year AS VARCHAR(4)) + '_W' + FORMAT(@WeekNumber, '00');

    IF NOT EXISTS (SELECT 1 FROM sys.filegroups WHERE name = @FileGroupName)
    BEGIN
        -- Create filegroup and file
        EXEC('ALTER DATABASE [DVC_v2] ADD FILEGROUP [' + @FileGroupName + ']');

        DECLARE @FilePath NVARCHAR(500) = 'D:\Database\DVC_v2\Audit\' + @FileGroupName + '.ndf';
        EXEC('ALTER DATABASE [DVC_v2]
              ADD FILE (
                  NAME = ''' + @FileGroupName + '_Data'',
                  FILENAME = ''' + @FilePath + ''',
                  SIZE = 500MB,
                  MAXSIZE = 20GB,
                  FILEGROWTH = 100MB
              ) TO FILEGROUP [' + @FileGroupName + ']');

        -- Split partition
        EXEC('ALTER PARTITION SCHEME ps_AUDIT_LOG_Weekly NEXT USED [' + @FileGroupName + ']');
        EXEC('ALTER PARTITION FUNCTION pf_AUDIT_LOG_Weekly() SPLIT RANGE (''' + CAST(@NextWeek AS VARCHAR(10)) + ''')');
    END

    -- Archive old audit logs (older than 7 years)
    DECLARE @ArchiveDate DATE = DATEADD(YEAR, -7, GETDATE());
    -- Archive to compliance storage and remove from active database

    -- Compress old partitions (older than 1 year)
    DECLARE @CompressionDate DATE = DATEADD(YEAR, -1, GETDATE());
    -- Enable page compression on old partitions
    DECLARE @PartitionNumber INT;
    DECLARE partition_cursor CURSOR FOR
    SELECT p.partition_number
    FROM sys.partitions p
    INNER JOIN sys.partition_schemes ps ON p.object_id = OBJECT_ID('[audit].AUDIT_LOG')
    WHERE p.rows > 0
    AND $PARTITION.pf_AUDIT_LOG_Weekly(p.partition_number) < @CompressionDate;

    OPEN partition_cursor;
    FETCH NEXT FROM partition_cursor INTO @PartitionNumber;

    WHILE @@FETCH_STATUS = 0
    BEGIN
        EXEC('ALTER TABLE [audit].AUDIT_LOG REBUILD PARTITION = ' + @PartitionNumber + ' WITH (DATA_COMPRESSION = PAGE)');
        FETCH NEXT FROM partition_cursor INTO @PartitionNumber;
    END

    CLOSE partition_cursor;
    DEALLOCATE partition_cursor;
END
GO
```

## OTHER HIGH-VOLUME TABLE PARTITIONING

### NOTIFICATION_QUEUE Partitioning

```sql
-- Monthly partitioning for notification queue
CREATE PARTITION FUNCTION pf_NOTIFICATION_QUEUE_Monthly (DATETIME2)
AS RANGE RIGHT FOR VALUES (
    '2024-01-01', '2024-02-01', '2024-03-01', '2024-04-01',
    '2024-05-01', '2024-06-01', '2024-07-01', '2024-08-01',
    '2024-09-01', '2024-10-01', '2024-11-01', '2024-12-01',
    '2025-01-01' -- Continue as needed
);
GO

CREATE PARTITION SCHEME ps_NOTIFICATION_QUEUE_Monthly
AS PARTITION pf_NOTIFICATION_QUEUE_Monthly
TO ([NOTIF_2024_01], [NOTIF_2024_02], [NOTIF_2024_03], [NOTIF_2024_04],
    [NOTIF_2024_05], [NOTIF_2024_06], [NOTIF_2024_07], [NOTIF_2024_08],
    [NOTIF_2024_09], [NOTIF_2024_10], [NOTIF_2024_11], [NOTIF_2024_12],
    [PRIMARY]);
GO
```

### DOCUMENT Partitioning

```sql
-- Yearly partitioning for documents (less frequent but large files)
CREATE PARTITION FUNCTION pf_DOCUMENT_Yearly (DATETIME2)
AS RANGE RIGHT FOR VALUES (
    '2020-01-01', '2021-01-01', '2022-01-01', '2023-01-01',
    '2024-01-01', '2025-01-01', '2026-01-01', '2027-01-01'
);
GO

CREATE PARTITION SCHEME ps_DOCUMENT_Yearly
AS PARTITION pf_DOCUMENT_Yearly
TO ([DOC_2020], [DOC_2021], [DOC_2022], [DOC_2023],
    [DOC_2024], [DOC_2025], [DOC_2026], [PRIMARY]);
GO
```

## PARTITIONING MAINTENANCE AUTOMATION

### Master Maintenance Job

```sql
CREATE PROCEDURE [dbo].sp_MasterPartitionMaintenance
AS
BEGIN
    SET NOCOUNT ON;

    BEGIN TRY
        -- Maintain HOSO partitions
        EXEC [case].sp_MaintainHOSOPartitions;

        -- Maintain AUDIT_LOG partitions
        EXEC [audit].sp_MaintainAuditLogPartitions;

        -- Update partition statistics
        EXEC sp_updatestats;

        -- Log maintenance completion
        INSERT INTO [system].MAINTENANCE_LOG (MaintenanceType, Status, CompletedAt)
        VALUES ('Partition Maintenance', 'SUCCESS', GETDATE());

    END TRY
    BEGIN CATCH
        -- Log error
        INSERT INTO [system].MAINTENANCE_LOG (MaintenanceType, Status, ErrorMessage, CompletedAt)
        VALUES ('Partition Maintenance', 'ERROR', ERROR_MESSAGE(), GETDATE());

        -- Re-raise error
        THROW;
    END CATCH
END
GO

-- Schedule master maintenance job
EXEC msdb.dbo.sp_add_job
    @job_name = N'Master Partition Maintenance',
    @enabled = 1;

EXEC msdb.dbo.sp_add_jobstep
    @job_name = N'Master Partition Maintenance',
    @step_name = N'Run All Partition Maintenance',
    @command = N'EXEC [dbo].sp_MasterPartitionMaintenance',
    @database_name = N'DVC_v2';

EXEC msdb.dbo.sp_add_schedule
    @schedule_name = N'Daily Partition Check',
    @freq_type = 4,
    @freq_interval = 1,
    @active_start_time = 10000; -- 1:00 AM

EXEC msdb.dbo.sp_attach_schedule
    @job_name = N'Master Partition Maintenance',
    @schedule_name = N'Daily Partition Check';
GO
```

## PARTITION MONITORING

### Partition Health Monitoring

```sql
CREATE VIEW [dbo].v_PartitionHealth AS
SELECT
    SCHEMA_NAME(t.schema_id) AS SchemaName,
    t.name AS TableName,
    i.name AS IndexName,
    p.partition_number,
    p.rows AS RowCount,
    p.data_compression_desc AS CompressionType,
    CAST(p.rows * 8.0 / 1024 / 1024 AS DECIMAL(10,2)) AS EstimatedSizeMB,
    fg.name AS FileGroupName,
    pf.name AS PartitionFunction,
    ps.name AS PartitionScheme
FROM sys.tables t
INNER JOIN sys.indexes i ON t.object_id = i.object_id
INNER JOIN sys.partitions p ON i.object_id = p.object_id AND i.index_id = p.index_id
INNER JOIN sys.allocation_units au ON p.partition_id = au.container_id
INNER JOIN sys.filegroups fg ON au.data_space_id = fg.data_space_id
LEFT JOIN sys.partition_schemes ps ON i.data_space_id = ps.data_space_id
LEFT JOIN sys.partition_functions pf ON ps.function_id = pf.function_id
WHERE i.index_id IN (0, 1) -- Heap or clustered index
AND t.name IN ('HOSO', 'AUDIT_LOG', 'NOTIFICATION_QUEUE', 'DOCUMENT')
GO

-- Partition performance monitoring
CREATE PROCEDURE [dbo].sp_MonitorPartitionPerformance
AS
BEGIN
    -- Check for partition elimination in query plans
    -- Monitor partition skipping efficiency
    -- Alert on inefficient cross-partition queries

    SELECT
        TableName,
        PartitionNumber,
        RowCount,
        EstimatedSizeMB,
        CASE
            WHEN RowCount > 1000000 THEN 'HIGH'
            WHEN RowCount > 500000 THEN 'MEDIUM'
            ELSE 'LOW'
        END AS LoadLevel,
        CASE
            WHEN CompressionType = 'NONE' AND EstimatedSizeMB > 1000 THEN 'COMPRESSION_RECOMMENDED'
            WHEN RowCount = 0 THEN 'EMPTY_PARTITION'
            ELSE 'OK'
        END AS RecommendedAction
    FROM [dbo].v_PartitionHealth
    ORDER BY SchemaName, TableName, PartitionNumber;
END
GO
```

## PERFORMANCE BENEFITS

### Expected Performance Improvements
1. **Query Performance**: 70-90% improvement for date-range queries
2. **Maintenance Operations**: 95% reduction in index rebuild time
3. **Backup/Restore**: Partition-level backup reduces time by 80%
4. **Archival**: Automated partition dropping vs manual data deletion

### Storage Benefits
1. **Compression**: Page compression on older partitions saves 50-70% space
2. **Archival**: Easy migration of old partitions to cheaper storage
3. **Growth Management**: Predictable storage growth patterns

### Operational Benefits
1. **Maintenance Windows**: No full table locks during partition operations
2. **Disaster Recovery**: Partition-level restore capabilities
3. **Data Lifecycle**: Automated archival and retention management
4. **Monitoring**: Detailed partition-level performance metrics

This partitioning strategy provides a solid foundation for handling the high-volume requirements of the DVC v2 system while maintaining performance and operational efficiency.