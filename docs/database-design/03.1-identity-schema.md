# [identity] Schema - Identity & Access Management

## OVERVIEW

The `[identity]` schema handles user authentication, authorization, and comprehensive role-based access control (RBAC) for the DVC v2 system. This schema supports multi-tenancy, hierarchical roles, delegation, and advanced security features.

## SCHEMA CREATION

```sql
-- Identity & Access Management
CREATE SCHEMA [identity];
GO
```

## CORE USER MANAGEMENT TABLES

### 1. USER_PROFILE - Core user information and authentication

```sql
CREATE TABLE [identity].USER_PROFILE (
    UserID BIGINT PRIMARY KEY IDENTITY,
    TenantID BIGINT NOT NULL, -- Multi-tenant support
    Username NVARCHAR(100) UNIQUE NOT NULL,
    Email NVARCHAR(255) UNIQUE NOT NULL,
    PasswordHash NVARCHAR(500) NOT NULL, -- BCrypt hash
    PasswordSalt NVARCHAR(100) NOT NULL,

    -- Personal Information
    HoVaTen NVARCHAR(255) NOT NULL,
    GioiTinhID BIGINT,
    Ngaysinh DATE,
    CCCD NVARCHAR(20), -- Căn cước công dân
    SoDienThoai NVARCHAR(20),
    DiaChi NVARCHAR(500),

    -- System Information
    Avatar NVARCHAR(500), -- URL to avatar image
    Language NVARCHAR(10) DEFAULT 'vi-VN',
    Timezone NVARCHAR(50) DEFAULT 'Asia/Ho_Chi_Minh',

    -- Security & Status
    IsActive BIT DEFAULT 1,
    IsEmailVerified BIT DEFAULT 0,
    IsPhoneVerified BIT DEFAULT 0,
    LastLoginAt DATETIME2,
    LoginFailureCount INT DEFAULT 0,
    AccountLockedUntil DATETIME2,

    -- Password Management
    PasswordChangedAt DATETIME2 DEFAULT GETDATE(),
    MustChangePassword BIT DEFAULT 0,
    PasswordResetToken NVARCHAR(500),
    PasswordResetExpiry DATETIME2,

    -- Two-Factor Authentication
    TwoFactorEnabled BIT DEFAULT 0,
    TwoFactorSecret NVARCHAR(500),
    BackupCodes NVARCHAR(1000), -- JSON array of backup codes

    -- Audit Trail
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    CreatedBy BIGINT,
    UpdatedAt DATETIME2,
    UpdatedBy BIGINT,
    DeletedAt DATETIME2,
    DeletedBy BIGINT,

    -- Constraints
    CONSTRAINT FK_USER_GioiTinh FOREIGN KEY (GioiTinhID) REFERENCES [lookup].DM_QG_GIOITINH(GioiTinhID),
    CONSTRAINT CK_USER_Email CHECK (Email LIKE '%@%.%'),
    CONSTRAINT CK_USER_Phone CHECK (SoDienThoai IS NULL OR LEN(SoDienThoai) >= 10)
);
GO

-- Indexes
CREATE INDEX IX_USER_TenantID ON [identity].USER_PROFILE(TenantID);
CREATE INDEX IX_USER_Username ON [identity].USER_PROFILE(Username);
CREATE INDEX IX_USER_Email ON [identity].USER_PROFILE(Email);
CREATE INDEX IX_USER_CCCD ON [identity].USER_PROFILE(CCCD);
CREATE INDEX IX_USER_Active ON [identity].USER_PROFILE(IsActive, TenantID);
CREATE INDEX IX_USER_LastLogin ON [identity].USER_PROFILE(LastLoginAt DESC);
GO
```

### 2. USER_SESSIONS - Session management for security tracking

```sql
CREATE TABLE [identity].USER_SESSIONS (
    SessionID NVARCHAR(128) PRIMARY KEY,
    UserID BIGINT NOT NULL,
    TenantID BIGINT NOT NULL,
    IPAddress NVARCHAR(45) NOT NULL, -- Support IPv6
    UserAgent NVARCHAR(1000),
    DeviceFingerprint NVARCHAR(500),
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    LastActivityAt DATETIME2 DEFAULT GETDATE(),
    ExpiresAt DATETIME2 NOT NULL,
    IsActive BIT DEFAULT 1,

    CONSTRAINT FK_SESSION_User FOREIGN KEY (UserID) REFERENCES [identity].USER_PROFILE(UserID) ON DELETE CASCADE
);
GO

-- Indexes
CREATE INDEX IX_SESSION_UserID ON [identity].USER_SESSIONS(UserID, IsActive);
CREATE INDEX IX_SESSION_Expiry ON [identity].USER_SESSIONS(ExpiresAt);
CREATE INDEX IX_SESSION_Activity ON [identity].USER_SESSIONS(LastActivityAt DESC);
GO
```

### 3. USER_LOGIN_HISTORY - Login audit trail

```sql
CREATE TABLE [identity].USER_LOGIN_HISTORY (
    LoginHistoryID BIGINT PRIMARY KEY IDENTITY,
    UserID BIGINT,
    Username NVARCHAR(100) NOT NULL, -- Store even if user doesn't exist
    LoginAttemptAt DATETIME2 DEFAULT GETDATE(),
    IPAddress NVARCHAR(45) NOT NULL,
    UserAgent NVARCHAR(1000),
    LoginResult NVARCHAR(50) NOT NULL, -- SUCCESS, FAILURE, LOCKED, etc.
    FailureReason NVARCHAR(255), -- Invalid password, account locked, etc.
    SessionID NVARCHAR(128)
);
GO

-- Indexes
CREATE INDEX IX_LOGINHISTORY_UserID ON [identity].USER_LOGIN_HISTORY(UserID, LoginAttemptAt DESC);
CREATE INDEX IX_LOGINHISTORY_Username ON [identity].USER_LOGIN_HISTORY(Username, LoginAttemptAt DESC);
CREATE INDEX IX_LOGINHISTORY_IP ON [identity].USER_LOGIN_HISTORY(IPAddress, LoginAttemptAt DESC);
CREATE INDEX IX_LOGINHISTORY_Result ON [identity].USER_LOGIN_HISTORY(LoginResult, LoginAttemptAt DESC);
GO
```

## RBAC (ROLE-BASED ACCESS CONTROL) SYSTEM

### 4. RBAC_ROLE - Role definitions with hierarchical support

```sql
CREATE TABLE [identity].RBAC_ROLE (
    RoleID BIGINT PRIMARY KEY IDENTITY,
    RoleCode NVARCHAR(100) UNIQUE NOT NULL,
    RoleName NVARCHAR(255) NOT NULL,
    RoleDescription NVARCHAR(1000),

    -- Role classification
    RoleType NVARCHAR(50) NOT NULL, -- System/Workflow/Functional/Department
    IsSystemRole BIT DEFAULT 0, -- System-defined role, cannot be deleted
    Level TINYINT DEFAULT 3, -- 1=Admin, 2=Manager, 3=Officer, 4=Staff

    -- Hierarchical support
    ParentRoleID BIGINT, -- For role hierarchy
    HierarchyPath NVARCHAR(500), -- /1/2/3 for fast hierarchy queries

    -- Permissions inheritance
    InheritPermissions BIT DEFAULT 1,
    CanDelegate BIT DEFAULT 0, -- Can this role be delegated?
    RequireApproval BIT DEFAULT 0, -- Delegation requires approval?

    -- Business rules
    MaxConcurrentUsers INT, -- Maximum users with this role
    SessionTimeout INT DEFAULT 480, -- Session timeout in minutes
    RequireTwoFactor BIT DEFAULT 0,

    -- Status and lifecycle
    IsActive BIT DEFAULT 1,
    EffectiveFrom DATETIME2 DEFAULT GETDATE(),
    EffectiveTo DATETIME2,

    -- Audit
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    CreatedBy BIGINT,
    UpdatedAt DATETIME2,
    UpdatedBy BIGINT,

    FOREIGN KEY (ParentRoleID) REFERENCES [identity].RBAC_ROLE(RoleID)
);
GO

-- Indexes
CREATE INDEX IX_ROLE_Code ON [identity].RBAC_ROLE(RoleCode);
CREATE INDEX IX_ROLE_Type ON [identity].RBAC_ROLE(RoleType, Level);
CREATE INDEX IX_ROLE_Hierarchy ON [identity].RBAC_ROLE(HierarchyPath);
CREATE INDEX IX_ROLE_Active ON [identity].RBAC_ROLE(IsActive, EffectiveFrom, EffectiveTo);
GO
```

### 5. RBAC_PERMISSION - Detailed permission definitions

```sql
CREATE TABLE [identity].RBAC_PERMISSION (
    PermissionID BIGINT PRIMARY KEY IDENTITY,
    PermissionCode NVARCHAR(100) UNIQUE NOT NULL,
    PermissionName NVARCHAR(255) NOT NULL,
    PermissionDescription NVARCHAR(1000),

    -- Permission categorization
    Module NVARCHAR(50) NOT NULL, -- User/Document/Workflow/Report/Admin/TTHC
    Action NVARCHAR(50) NOT NULL, -- Create/Read/Update/Delete/Execute/Approve/Process
    Resource NVARCHAR(100), -- Specific resource or wildcard (*)

    -- Permission scope
    Scope NVARCHAR(50) DEFAULT 'Organization', -- Global/Organization/Department/Self
    RequireOwnership BIT DEFAULT 0, -- Only access own records?
    DataFilter NVARCHAR(1000), -- Additional data filtering rules (JSON)

    -- Security level
    SecurityLevel TINYINT DEFAULT 1, -- 1=Normal, 2=Sensitive, 3=Confidential, 4=Secret
    RequireApproval BIT DEFAULT 0, -- Usage requires approval?
    LogAccess BIT DEFAULT 0, -- Log every access?

    -- Business rules
    BusinessRules NVARCHAR(2000), -- JSON business rules for this permission
    TimeBasedAccess BIT DEFAULT 0, -- Time-based access control?
    WorkingHoursOnly BIT DEFAULT 0,

    -- Status
    IsActive BIT DEFAULT 1,
    IsSystemPermission BIT DEFAULT 0, -- System-defined, cannot be deleted

    -- Audit
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    CreatedBy BIGINT,
    UpdatedAt DATETIME2,
    UpdatedBy BIGINT
);
GO

-- Indexes
CREATE INDEX IX_PERMISSION_Code ON [identity].RBAC_PERMISSION(PermissionCode);
CREATE INDEX IX_PERMISSION_Module_Action ON [identity].RBAC_PERMISSION(Module, Action);
CREATE INDEX IX_PERMISSION_Resource ON [identity].RBAC_PERMISSION(Resource);
CREATE INDEX IX_PERMISSION_Scope ON [identity].RBAC_PERMISSION(Scope, SecurityLevel);
CREATE INDEX IX_PERMISSION_Active ON [identity].RBAC_PERMISSION(IsActive, Module);
GO
```

### 6. ROLE_PERMISSION - Map permissions to roles

```sql
CREATE TABLE [identity].ROLE_PERMISSION (
    RolePermissionID BIGINT PRIMARY KEY IDENTITY,
    RoleID BIGINT NOT NULL,
    PermissionID BIGINT NOT NULL,

    -- Grant details
    IsGranted BIT DEFAULT 1, -- True=Granted, False=Explicitly denied
    GrantType TINYINT DEFAULT 1, -- 1=Direct, 2=Inherited, 3=Conditional

    -- Conditional grants
    Conditions NVARCHAR(2000), -- JSON conditions when permission applies
    ContextData NVARCHAR(1000), -- Additional context for conditional permissions

    -- Overrides and exceptions
    CanOverride BIT DEFAULT 0, -- Can be overridden at user level?
    OverrideReason NVARCHAR(500),

    -- Temporal grants
    EffectiveFrom DATETIME2 DEFAULT GETDATE(),
    EffectiveTo DATETIME2, -- NULL = permanent

    -- Grant management
    GrantedBy BIGINT NOT NULL,
    GrantedAt DATETIME2 DEFAULT GETDATE(),
    LastReviewed DATETIME2,
    ReviewedBy BIGINT,

    -- Status
    IsActive BIT DEFAULT 1,

    -- Audit
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    CreatedBy BIGINT,
    UpdatedAt DATETIME2,
    UpdatedBy BIGINT,

    FOREIGN KEY (RoleID) REFERENCES [identity].RBAC_ROLE(RoleID),
    FOREIGN KEY (PermissionID) REFERENCES [identity].RBAC_PERMISSION(PermissionID),
    UNIQUE (RoleID, PermissionID) -- One grant per role-permission pair
);
GO

-- Indexes
CREATE INDEX IX_ROLEPERM_Role ON [identity].ROLE_PERMISSION(RoleID, IsActive);
CREATE INDEX IX_ROLEPERM_Permission ON [identity].ROLE_PERMISSION(PermissionID, IsGranted);
CREATE INDEX IX_ROLEPERM_Effective ON [identity].ROLE_PERMISSION(EffectiveFrom, EffectiveTo);
CREATE INDEX IX_ROLEPERM_GrantedBy ON [identity].ROLE_PERMISSION(GrantedBy, GrantedAt DESC);
GO
```

### 7. USER_ROLE - Assign roles to users

```sql
CREATE TABLE [identity].USER_ROLE (
    UserRoleID BIGINT PRIMARY KEY IDENTITY,
    UserID BIGINT NOT NULL,
    RoleID BIGINT NOT NULL,

    -- Assignment scope
    DonViID BIGINT, -- Assigned to specific organization unit
    PhongBanID INT, -- Assigned to specific department
    AssignmentScope NVARCHAR(50) DEFAULT 'Organization', -- Global/Organization/Department

    -- Assignment details
    AssignmentType TINYINT DEFAULT 1, -- 1=Permanent, 2=Temporary, 3=Project, 4=Emergency
    Reason NVARCHAR(1000), -- Reason for assignment
    ApprovalRequired BIT DEFAULT 0,

    -- Temporal assignment
    EffectiveFrom DATETIME2 DEFAULT GETDATE(),
    EffectiveTo DATETIME2, -- NULL = permanent
    IsTemporary BIT AS (CASE WHEN EffectiveTo IS NOT NULL THEN 1 ELSE 0 END) PERSISTED,

    -- Assignment management
    AssignedBy BIGINT NOT NULL,
    AssignedAt DATETIME2 DEFAULT GETDATE(),
    ApprovedBy BIGINT,
    ApprovedAt DATETIME2,

    -- Review and audit
    LastReviewed DATETIME2,
    ReviewedBy BIGINT,
    NextReviewDue DATETIME2,

    -- Status
    IsActive BIT DEFAULT 1,
    Status TINYINT DEFAULT 1, -- 1=Active, 2=Pending approval, 3=Suspended, 4=Expired

    -- Notification
    NotificationSent BIT DEFAULT 0,
    ExpirationWarningDays INT DEFAULT 30, -- Warn X days before expiration

    -- Audit
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    CreatedBy BIGINT,
    UpdatedAt DATETIME2,
    UpdatedBy BIGINT,

    CONSTRAINT FK_USER_ROLE_USER FOREIGN KEY (UserID) REFERENCES [identity].USER_PROFILE(UserID),
    CONSTRAINT FK_USER_ROLE_ROLE FOREIGN KEY (RoleID) REFERENCES [identity].RBAC_ROLE(RoleID)
);
GO

CREATE INDEX IX_USERROLE_User ON [identity].USER_ROLE (UserID, IsActive);
CREATE INDEX IX_USERROLE_Role ON [identity].USER_ROLE (RoleID, IsActive);
CREATE INDEX IX_USERROLE_DonVi ON [identity].USER_ROLE (DonViID, IsActive);
CREATE INDEX IX_USERROLE_Effective ON [identity].USER_ROLE (EffectiveFrom, EffectiveTo);
CREATE INDEX IX_USERROLE_Review ON [identity].USER_ROLE (NextReviewDue, IsActive);
CREATE INDEX IX_USERROLE_Assignment ON [identity].USER_ROLE (AssignedBy, AssignedAt DESC);
GO
```

### 8. ROLE_HIERARCHY - Role inheritance hierarchy

```sql
CREATE TABLE [identity].ROLE_HIERARCHY (
    RoleHierarchyID BIGINT PRIMARY KEY IDENTITY,
    ParentRoleID BIGINT NOT NULL,
    ChildRoleID BIGINT NOT NULL,

    -- Inheritance rules
    InheritanceType NVARCHAR(50) DEFAULT 'Full', -- Full/Partial/Override/Conditional
    Priority INT DEFAULT 0, -- Higher priority = higher precedence

    -- Conditional inheritance
    InheritanceConditions NVARCHAR(2000), -- JSON conditions for inheritance
    OverrideRules NVARCHAR(2000), -- JSON override rules

    -- Inheritance scope
    InheritPermissions BIT DEFAULT 1,
    InheritConstraints BIT DEFAULT 1,
    InheritDataAccess BIT DEFAULT 0, -- Inherit data access patterns?

    -- Status
    IsActive BIT DEFAULT 1,
    EffectiveFrom DATETIME2 DEFAULT GETDATE(),
    EffectiveTo DATETIME2,

    -- Audit
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    CreatedBy BIGINT,
    UpdatedAt DATETIME2,
    UpdatedBy BIGINT,

    FOREIGN KEY (ParentRoleID) REFERENCES [identity].RBAC_ROLE(RoleID),
    FOREIGN KEY (ChildRoleID) REFERENCES [identity].RBAC_ROLE(RoleID),
    CONSTRAINT CK_ROLEHIERARCHY_NoSelfReference CHECK (ParentRoleID != ChildRoleID)
);
GO

-- Indexes
CREATE INDEX IX_ROLEHIERARCHY_Parent ON [identity].ROLE_HIERARCHY(ParentRoleID, IsActive);
CREATE INDEX IX_ROLEHIERARCHY_Child ON [identity].ROLE_HIERARCHY(ChildRoleID, IsActive);
CREATE INDEX IX_ROLEHIERARCHY_Priority ON [identity].ROLE_HIERARCHY(Priority DESC);
GO
```

## ADVANCED RBAC FEATURES

### 9. DYNAMIC_ROLE_MAPPING - Dynamic role assignment based on conditions

```sql
CREATE TABLE [identity].DYNAMIC_ROLE_MAPPING (
    DynamicRoleMappingID BIGINT PRIMARY KEY IDENTITY,
    SourceRoleID BIGINT NOT NULL,
    TargetRoleID BIGINT NOT NULL,

    -- Mapping conditions
    ConditionType NVARCHAR(50) NOT NULL, -- Amount/Department/Document/Time/Attribute
    ConditionOperator NVARCHAR(20) NOT NULL, -- >,<,=,IN,BETWEEN,CONTAINS
    ConditionValue NVARCHAR(2000) NOT NULL, -- JSON value(s) to compare against

    -- Complex conditions
    ConditionExpression NVARCHAR(4000), -- Full condition expression for complex rules
    EvaluationContext NVARCHAR(1000), -- Context variables for evaluation

    -- Mapping behavior
    MappingType NVARCHAR(50) DEFAULT 'Temporary', -- Temporary/Permanent/Conditional
    AutoActivate BIT DEFAULT 1, -- Automatically activate when conditions are met?
    Duration INT, -- Duration in hours for temporary mappings

    -- Priority and precedence
    Priority INT DEFAULT 0,
    OverrideExisting BIT DEFAULT 0, -- Override existing role assignments?

    -- Evaluation frequency
    EvaluationFrequency NVARCHAR(50) DEFAULT 'OnDemand', -- OnDemand/Hourly/Daily/Event
    LastEvaluated DATETIME2,
    NextEvaluation DATETIME2,

    -- Status
    IsActive BIT DEFAULT 1,

    -- Audit
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    CreatedBy BIGINT,
    UpdatedAt DATETIME2,
    UpdatedBy BIGINT,

    CONSTRAINT FK_DYNAMIC_ROLE_MAPPING_SOURCE_ROLE FOREIGN KEY (SourceRoleID) REFERENCES [identity].RBAC_ROLE(RoleID),
    CONSTRAINT FK_DYNAMIC_ROLE_MAPPING_TARGET_ROLE FOREIGN KEY (TargetRoleID) REFERENCES [identity].RBAC_ROLE(RoleID)
);
GO

CREATE INDEX IX_DYNAMICROLE_Source ON [identity].DYNAMIC_ROLE_MAPPING (SourceRoleID, ConditionType);
CREATE INDEX IX_DYNAMICROLE_Target ON [identity].DYNAMIC_ROLE_MAPPING (TargetRoleID, IsActive);
CREATE INDEX IX_DYNAMICROLE_Evaluation ON [identity].DYNAMIC_ROLE_MAPPING (NextEvaluation, IsActive);
CREATE INDEX IX_DYNAMICROLE_Priority ON [identity].DYNAMIC_ROLE_MAPPING (Priority DESC);
GO
```

### 10. DELEGATION_HISTORY - Role delegation audit trail

```sql
CREATE TABLE [identity].DELEGATION_HISTORY (
    DelegationID BIGINT PRIMARY KEY IDENTITY,
    DelegatorID BIGINT NOT NULL, -- User who delegates
    DelegateID BIGINT NOT NULL, -- User who receives delegation
    RoleID BIGINT NOT NULL,

    -- Delegation details
    DelegationType NVARCHAR(50) DEFAULT 'Temporary', -- Temporary/Permanent/Conditional/Emergency
    Reason NVARCHAR(2000) NOT NULL,

    -- Scope and limitations
    DelegationScope NVARCHAR(50) DEFAULT 'All', -- All/Specific/Limited
    ScopeDetails NVARCHAR(4000), -- JSON details of delegation scope
    Limitations NVARCHAR(2000), -- JSON limitations and restrictions

    -- Timing
    StartDate DATETIME2 NOT NULL,
    EndDate DATETIME2,
    ActualStartDate DATETIME2,
    ActualEndDate DATETIME2,

    -- Approval workflow
    ApprovalRequired BIT DEFAULT 0,
    ApprovedBy BIGINT,
    ApprovedAt DATETIME2,
    ApprovalComments NVARCHAR(1000),

    -- Status management
    Status NVARCHAR(50) DEFAULT 'Pending', -- Pending/Approved/Active/Expired/Revoked/Cancelled
    StatusReason NVARCHAR(1000),

    -- Revocation
    RevokedBy BIGINT,
    RevokedAt DATETIME2,
    RevocationReason NVARCHAR(1000),

    -- Notifications
    DelegateNotified BIT DEFAULT 0,
    DelegatorNotified BIT DEFAULT 0,
    SupervisorNotified BIT DEFAULT 0,

    -- Performance tracking
    UsageCount INT DEFAULT 0, -- How many times delegation was used
    LastUsed DATETIME2,

    -- Audit
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    CreatedBy BIGINT,
    UpdatedAt DATETIME2,
    UpdatedBy BIGINT,

    CONSTRAINT FK_DELEGATION_HISTORY_DELEGATOR FOREIGN KEY (DelegatorID) REFERENCES [identity].USER_PROFILE(UserID),
    CONSTRAINT FK_DELEGATION_HISTORY_DELEGATE FOREIGN KEY (DelegateID) REFERENCES [identity].USER_PROFILE(UserID),
    CONSTRAINT FK_DELEGATION_HISTORY_ROLE FOREIGN KEY (RoleID) REFERENCES [identity].RBAC_ROLE(RoleID),
    CONSTRAINT FK_DELEGATION_HISTORY_APPROVED_BY FOREIGN KEY (ApprovedBy) REFERENCES [identity].USER_PROFILE(UserID),
    CONSTRAINT FK_DELEGATION_HISTORY_REVOKED_BY FOREIGN KEY (RevokedBy) REFERENCES [identity].USER_PROFILE(UserID)
);
GO

CREATE INDEX IX_DELEGATION_Delegator ON [identity].DELEGATION_HISTORY (DelegatorID, Status);
CREATE INDEX IX_DELEGATION_Delegate ON [identity].DELEGATION_HISTORY (DelegateID, Status);
CREATE INDEX IX_DELEGATION_Role ON [identity].DELEGATION_HISTORY (RoleID, Status);
CREATE INDEX IX_DELEGATION_Period ON [identity].DELEGATION_HISTORY (StartDate, EndDate);
CREATE INDEX IX_DELEGATION_Status ON [identity].DELEGATION_HISTORY (Status, CreatedAt DESC);
CREATE INDEX IX_DELEGATION_Approval ON [identity].DELEGATION_HISTORY (ApprovalRequired, ApprovedAt);
GO
```

### 11. TEMPORAL_ROLE_ASSIGNMENT - Temporary role assignments

```sql
CREATE TABLE [identity].TEMPORAL_ROLE_ASSIGNMENT (
    TemporalRoleID BIGINT PRIMARY KEY IDENTITY,
    UserID BIGINT NOT NULL,
    RoleID BIGINT NOT NULL,

    -- Assignment reason and type
    AssignmentType NVARCHAR(50) NOT NULL, -- Vacation/Training/Project/Emergency/Acting
    OriginalUserID BIGINT, -- User being replaced (for vacation, etc.)
    ProjectID NVARCHAR(100), -- Project or initiative ID

    -- Timing
    StartDate DATETIME2 NOT NULL,
    EndDate DATETIME2 NOT NULL,
    ActualStartDate DATETIME2,
    ActualEndDate DATETIME2,

    -- Auto-management
    AutoRevert BIT DEFAULT 1, -- Automatically remove when period ends?
    NotificationDays INT DEFAULT 7, -- Days before end to send notification
    LastNotificationSent DATETIME2,

    -- Approval and authorization
    ApprovedBy BIGINT NOT NULL,
    ApprovedAt DATETIME2 DEFAULT GETDATE(),
    ApprovalComments NVARCHAR(1000),

    -- Assignment details
    Reason NVARCHAR(2000) NOT NULL,
    Justification NVARCHAR(2000),
    SpecialInstructions NVARCHAR(2000),

    -- Scope and limitations
    AssignmentScope NVARCHAR(2000), -- JSON scope definition
    Limitations NVARCHAR(2000), -- JSON limitations
    AdditionalPermissions NVARCHAR(2000), -- JSON additional permissions if any

    -- Status tracking
    Status NVARCHAR(50) DEFAULT 'Scheduled', -- Scheduled/Active/Completed/Cancelled/Expired

    -- Audit
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    CreatedBy BIGINT,
    UpdatedAt DATETIME2,
    UpdatedBy BIGINT,

    CONSTRAINT FK_TEMPORAL_ROLE_ASSIGNMENT_USER FOREIGN KEY (UserID) REFERENCES [identity].USER_PROFILE(UserID),
    CONSTRAINT FK_TEMPORAL_ROLE_ASSIGNMENT_ROLE FOREIGN KEY (RoleID) REFERENCES [identity].RBAC_ROLE(RoleID),
    CONSTRAINT FK_TEMPORAL_ROLE_ASSIGNMENT_ORIGINAL_USER FOREIGN KEY (OriginalUserID) REFERENCES [identity].USER_PROFILE(UserID),
    CONSTRAINT FK_TEMPORAL_ROLE_ASSIGNMENT_APPROVED_BY FOREIGN KEY (ApprovedBy) REFERENCES [identity].USER_PROFILE(UserID)
);
GO

CREATE INDEX IX_TEMPORALROLE_User ON [identity].TEMPORAL_ROLE_ASSIGNMENT (UserID, Status);
CREATE INDEX IX_TEMPORALROLE_Role ON [identity].TEMPORAL_ROLE_ASSIGNMENT (RoleID, Status);
CREATE INDEX IX_TEMPORALROLE_Period ON [identity].TEMPORAL_ROLE_ASSIGNMENT (StartDate, EndDate);
CREATE INDEX IX_TEMPORALROLE_Type ON [identity].TEMPORAL_ROLE_ASSIGNMENT (AssignmentType, Status);
CREATE INDEX IX_TEMPORALROLE_Original ON [identity].TEMPORAL_ROLE_ASSIGNMENT (OriginalUserID, Status);
CREATE INDEX IX_TEMPORALROLE_Notification ON [identity].TEMPORAL_ROLE_ASSIGNMENT (EndDate, LastNotificationSent);
CREATE INDEX IX_TEMPORALROLE_Status ON [identity].TEMPORAL_ROLE_ASSIGNMENT (Status, CreatedAt DESC);
GO
```

## NATIONAL IDENTITY INTEGRATION

### 12. CONGDANDOANHNGHIEP - Citizens/businesses from national database

```sql
CREATE TABLE [identity].CONGDANDOANHNGHIEP (
    ThongTinCongDanID BIGINT PRIMARY KEY IDENTITY,

    -- National ID integration
    TechID UNIQUEIDENTIFIER NOT NULL, -- UUID from VNEID login
    LoaiDangKy TINYINT NOT NULL, -- 1=Citizen, 2=Business

    -- Basic information
    TenDayDu NVARCHAR(255) NOT NULL,
    DoB DATE,
    GioiTinhID BIGINT,

    -- Identification
    LoaiGiayTo TINYINT,
    SoGiayTo NVARCHAR(50),
    NgayCap DATE,
    NoiCap NVARCHAR(255),

    -- Ethnicity and nationality
    DanTocID INT,
    QuocTichID INT,

    -- Contact
    SoDienThoai NVARCHAR(20),
    Email NVARCHAR(255),

    -- Birth place
    NoiSinhQuocGiaID INT,
    NoiSinhTinhThanhID INT,
    NoiSinhPhuongXaID INT,
    NoiSinhChiTiet NVARCHAR(500),

    -- Current address
    ThuongTruQuocGiaID INT,
    ThuongTruTinhThanhID INT,
    ThuongTruPhuongXaID INT,
    ThuongTruChiTiet NVARCHAR(500),

    -- Business information (for businesses)
    MaSoThue NVARCHAR(50),
    TenDoanhNghiep NVARCHAR(500),
    NgayThanhLap DATE,
    VonDieuLe DECIMAL(18,2),

    -- Audit
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    UpdatedAt DATETIME2,

    CONSTRAINT FK_CONGDANDOANHNGHIEP_GIOITINH FOREIGN KEY (GioiTinhID) REFERENCES [lookup].DM_QG_GIOITINH(GioiTinhID)
);
GO

CREATE INDEX IX_CONGDAN_TechID ON [identity].CONGDANDOANHNGHIEP (TechID);
CREATE INDEX IX_CONGDAN_SoGiayTo ON [identity].CONGDANDOANHNGHIEP (SoGiayTo);
CREATE INDEX IX_CONGDAN_TenDayDu ON [identity].CONGDANDOANHNGHIEP (TenDayDu);
CREATE INDEX IX_CONGDAN_LoaiDangKy ON [identity].CONGDANDOANHNGHIEP (LoaiDangKy);
GO
```

## ENHANCED BUSINESS RULES SUPPORT

### 13. PERMISSION_CONDITIONS - Normalized permission conditions

```sql
CREATE TABLE [identity].PERMISSION_CONDITIONS (
    ConditionID BIGINT PRIMARY KEY IDENTITY,
    PermissionID BIGINT NOT NULL,

    -- Condition definition
    FieldName NVARCHAR(100) NOT NULL, -- e.g., 'user.department', 'case.amount', 'time.hour'
    Operator NVARCHAR(20) NOT NULL, -- =, !=, >, <, >=, <=, IN, NOT_IN, CONTAINS, BETWEEN
    Value1 NVARCHAR(500), -- Primary value
    Value2 NVARCHAR(500), -- For BETWEEN operator

    -- Logical grouping
    GroupID INT DEFAULT 1, -- For grouping with AND
    GroupOperator NVARCHAR(10) DEFAULT 'AND', -- AND, OR between groups

    -- Rule metadata
    Description NVARCHAR(500),
    IsActive BIT DEFAULT 1,
    CreatedAt DATETIME2 DEFAULT GETDATE(),
    CreatedBy BIGINT NOT NULL,

    CONSTRAINT FK_PERMCOND_Permission FOREIGN KEY (PermissionID) REFERENCES [identity].RBAC_PERMISSION(PermissionID) ON DELETE CASCADE
);
GO

CREATE INDEX IX_PERMCOND_Permission ON [identity].PERMISSION_CONDITIONS(PermissionID, IsActive);
CREATE INDEX IX_PERMCOND_Field ON [identity].PERMISSION_CONDITIONS(FieldName, Operator);
GO
```

## SECURITY FUNCTIONS

### Row-Level Security Function

```sql
-- Function for row-level security
CREATE FUNCTION dbo.fn_SecurityPredicate(@DonViID BIGINT)
RETURNS TABLE
WITH SCHEMABINDING
AS
RETURN
(
    SELECT 1 AS fn_securitypredicate_result
    WHERE @DonViID IN (
        SELECT dv.DonViID
        FROM [organization].DM_DONVI dv
        INNER JOIN [identity].USER_ROLE ur ON ur.DonViID = dv.DonViID
        WHERE ur.UserID = CAST(SESSION_CONTEXT(N'UserId') AS BIGINT)
            AND ur.IsActive = 1
    )
    OR IS_MEMBER('db_owner') = 1
);
GO
```

## KEY FEATURES

### Multi-tenant Support
- **TenantID** in USER_PROFILE and sessions for complete tenant isolation
- Tenant-aware indexes for optimal performance
- Row-Level Security (RLS) policies for data protection

### Advanced RBAC Features
- **Hierarchical Roles**: Support for role inheritance and hierarchies
- **Conditional Permissions**: Complex business rules with normalized conditions
- **Dynamic Role Mapping**: Automatic role assignment based on business rules
- **Delegation Management**: Comprehensive role delegation with approval workflows
- **Temporal Assignments**: Time-bound role assignments with auto-expiration and notifications
- **Audit Trail**: Complete audit trail for all security-related operations

### Security Features
- **Password Management**: BCrypt hashing, expiration, reset tokens
- **Two-Factor Authentication**: Secret management and backup codes
- **Session Management**: Comprehensive session tracking and security
- **Login Auditing**: Detailed login attempt tracking and analysis
- **Account Locking**: Automatic account protection against brute force attacks

### Integration Features
- **National Identity**: Integration with Vietnamese national identity system
- **Cross-Schema Integration**: Secure integration with other service schemas
- **Event-Driven Architecture**: Support for microservices communication patterns

## MIGRATION CONSIDERATIONS

### From JSON to Normalized Business Rules
```sql
-- Example migration from JSON BusinessRules to normalized PERMISSION_CONDITIONS
INSERT INTO [identity].PERMISSION_CONDITIONS (PermissionID, FieldName, Operator, Value1, CreatedBy)
SELECT
    p.PermissionID,
    JSON_VALUE(p.BusinessRules, '$.field'),
    JSON_VALUE(p.BusinessRules, '$.operator'),
    JSON_VALUE(p.BusinessRules, '$.value'),
    1 -- System user
FROM [identity].RBAC_PERMISSION p
WHERE p.BusinessRules IS NOT NULL
AND ISJSON(p.BusinessRules) = 1;

-- After migration and verification, drop JSON column
ALTER TABLE [identity].RBAC_PERMISSION DROP COLUMN BusinessRules;
```

### Microservices Extraction Readiness
This schema is designed to be easily extracted as a separate Identity microservice:
- Self-contained user management
- Clear API boundaries through views
- Event-driven integration patterns
- Minimal dependencies on other schemas (only lookup tables)